$date
	Fri Jun 12 19:09:55 2020
$end
$version
	Icarus Verilog
$end
$timescale
	1ns
$end
$scope module alu32bittb $end
$var wire 1 ! sig_branch $end
$var wire 32 " ALU_result [31:0] $end
$var reg 6 # funct [5:0] $end
$var reg 16 $ immediate [15:0] $end
$var reg 6 % opcode [5:0] $end
$var reg 32 & rs_content [31:0] $end
$var reg 32 ' rt_content [31:0] $end
$var reg 5 ( shamt [4:0] $end
$scope module testerboi $end
$var wire 6 ) funct [5:0] $end
$var wire 16 * immediate [15:0] $end
$var wire 6 + opcode [5:0] $end
$var wire 32 , rs_content [31:0] $end
$var wire 32 - rt_content [31:0] $end
$var wire 5 . shamt [4:0] $end
$var reg 32 / ALU_result [31:0] $end
$var reg 1 ! sig_branch $end
$var reg 32 0 signExtend [31:0] $end
$var reg 32 1 signed_rs [31:0] $end
$var reg 32 2 signed_rt [31:0] $end
$var reg 32 3 temp [31:0] $end
$var reg 32 4 zeroExtend [31:0] $end
$var integer 32 5 i [31:0] $end
$upscope $end
$upscope $end
$scope module control_unit_tb $end
$upscope $end
$scope module ins_parsertb $end
$var wire 5 6 shamt [4:0] $end
$var wire 5 7 rt [4:0] $end
$var wire 5 8 rs [4:0] $end
$var wire 5 9 rd [4:0] $end
$var wire 6 : opcode [5:0] $end
$var wire 16 ; immediate [15:0] $end
$var wire 6 < funct [5:0] $end
$var wire 26 = address [25:0] $end
$var reg 32 > instruction [31:0] $end
$var reg 32 ? p_count [31:0] $end
$scope module instructionParser $end
$var wire 32 @ instruction [31:0] $end
$var wire 32 A p_count [31:0] $end
$var wire 6 B opcode [5:0] $end
$var reg 26 C address [25:0] $end
$var reg 6 D funct [5:0] $end
$var reg 16 E immediate [15:0] $end
$var reg 5 F rd [4:0] $end
$var reg 5 G rs [4:0] $end
$var reg 5 H rt [4:0] $end
$var reg 5 I shamt [4:0] $end
$upscope $end
$upscope $end
$scope module mips_testbench $end
$scope module test $end
$var wire 1 J branch_signal $end
$var wire 1 K clock $end
$var wire 32 L write_data [31:0] $end
$var wire 5 M shamt [4:0] $end
$var wire 32 N rt_content [31:0] $end
$var wire 5 O rt [4:0] $end
$var wire 32 P rs_content [31:0] $end
$var wire 5 Q rs [4:0] $end
$var wire 5 R rd [4:0] $end
$var wire 6 S opcode [5:0] $end
$var wire 32 T memory_read_data [31:0] $end
$var wire 32 U instruction [31:0] $end
$var wire 16 V immediate [15:0] $end
$var wire 6 W funct [5:0] $end
$var wire 26 X address [25:0] $end
$var wire 1 Y RegWrite $end
$var wire 1 Z RegRead $end
$var wire 1 [ RegDst $end
$var wire 1 \ MemWrite $end
$var wire 1 ] MemRead $end
$var reg 32 ^ PC [31:0] $end
$scope module alu_process $end
$var wire 5 _ shamt [4:0] $end
$var wire 32 ` rt_content [31:0] $end
$var wire 32 a rs_content [31:0] $end
$var wire 6 b opcode [5:0] $end
$var wire 16 c immediate [15:0] $end
$var wire 6 d funct [5:0] $end
$var reg 32 e ALU_result [31:0] $end
$var reg 1 f sig_branch $end
$var reg 32 g signExtend [31:0] $end
$var reg 32 h signed_rs [31:0] $end
$var reg 32 i signed_rt [31:0] $end
$var reg 32 j temp [31:0] $end
$var reg 32 k zeroExtend [31:0] $end
$var integer 32 l i [31:0] $end
$upscope $end
$scope module contents $end
$var wire 1 K clk $end
$var wire 32 m write_data [31:0] $end
$var wire 5 n rt [4:0] $end
$var wire 5 o rs [4:0] $end
$var wire 5 p rd [4:0] $end
$var wire 6 q opcode [5:0] $end
$var wire 1 Y RegWrite $end
$var wire 1 Z RegRead $end
$var wire 1 [ RegDst $end
$var reg 32 r read_data_1 [31:0] $end
$var reg 32 s read_data_2 [31:0] $end
$upscope $end
$scope module dataMemory $end
$var wire 32 t address [31:0] $end
$var wire 32 u write_data [31:0] $end
$var wire 6 v opcode [5:0] $end
$var wire 1 \ MemWrite $end
$var wire 1 ] MemRead $end
$var reg 32 w read_data [31:0] $end
$upscope $end
$scope module inst_mem $end
$var wire 32 x program_counter [31:0] $end
$var reg 32 y instruction [31:0] $end
$upscope $end
$scope module parse $end
$var wire 32 z instruction [31:0] $end
$var wire 32 { p_count [31:0] $end
$var wire 6 | opcode [5:0] $end
$var reg 26 } address [25:0] $end
$var reg 6 ~ funct [5:0] $end
$var reg 16 !" immediate [15:0] $end
$var reg 5 "" rd [4:0] $end
$var reg 5 #" rs [4:0] $end
$var reg 5 $" rt [4:0] $end
$var reg 5 %" shamt [4:0] $end
$upscope $end
$scope module signals $end
$var wire 6 &" funct [5:0] $end
$var wire 6 '" opcode [5:0] $end
$var reg 1 (" Branch $end
$var reg 1 ] MemRead $end
$var reg 1 \ MemWrite $end
$var reg 1 [ RegDst $end
$var reg 1 Z RegRead $end
$var reg 1 Y RegWrite $end
$upscope $end
$upscope $end
$upscope $end
$scope module mips_testbench $end
$var reg 1 K clock $end
$scope module test $end
$scope module alu_process $end
$upscope $end
$scope module contents $end
$upscope $end
$scope module dataMemory $end
$upscope $end
$scope module inst_mem $end
$upscope $end
$scope module parse $end
$upscope $end
$scope module signals $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
0("
b1000 '"
bx &"
bx %"
b101 $"
b100 #"
bx ""
b10001000 !"
bx ~
bx }
b1000 |
b0 {
b100000100001010000000010001000 z
b100000100001010000000010001000 y
b0 x
bx w
b1000 v
bx u
bx t
bx s
bx r
b1000 q
bx p
b100 o
b101 n
bx m
bx l
b10001000 k
bx j
bx i
bx h
b10001000 g
xf
bx e
bx d
b10001000 c
b1000 b
bx a
bx `
bx _
b0 ^
0]
0\
0[
1Z
1Y
bx X
bx W
b10001000 V
b100000100001010000000010001000 U
bx T
b1000 S
bx R
b100 Q
bx P
b101 O
bx N
bx M
bx L
0K
xJ
b0 I
b11 H
b1000 G
b10 F
bx E
b100010 D
bx C
b0 B
bx A
b1000000110001000000100010 @
bx ?
b1000000110001000000100010 >
bx =
b100010 <
bx ;
b0 :
b10 9
b1000 8
b11 7
b0 6
bx 5
bx 4
bx 3
b11111111111111111111111111110110 2
b1100 1
bx 0
b10 /
b0 .
b11111111111111111111111111110110 -
b1100 ,
b0 +
b10100 *
b100000 )
b0 (
b11111111111111111111111111110110 '
b1100 &
b0 %
b10100 $
b100000 #
b10 "
x!
$end
#10
b1010 ;
b1010 E
b1 8
b1 G
b110 7
b110 H
b1000 :
b1000 B
b11111111111111111111111111111110 "
b11111111111111111111111111111110 /
b11 2
b1 1
b100000001001100000000000001010 >
b100000001001100000000000001010 @
b100010 #
b100010 )
b11 '
b11 -
b1 &
b1 ,
#20
b100000001 =
b100000001 C
b10 :
b10 B
b110100 "
b110100 /
b1101 2
b0 1
b1000000000000000000100000001 >
b1000000000000000000100000001 @
b10 (
b10 .
b0 #
b0 )
b1101 '
b1101 -
b0 &
b0 ,
#30
b100000 <
b100000 D
b10001 8
b10001 G
b10010 7
b10010 H
b1000 9
b1000 F
b0 :
b0 B
b10111101011 "
b10111101011 /
b10111011100 4
b10111011100 0
b0 2
b1111 1
b10001100100100000000100000 >
b10001100100100000000100000 @
b10111011100 $
b10111011100 *
b0 '
b0 -
b1111 &
b1111 ,
b1000 %
b1000 +
#40
b1000110011 =
b1000110011 C
b11 :
b11 B
b10000000111 "
b10000000111 /
b10000000000 4
b10000000000 0
b111 1
b1100000000000000001000110011 >
b1100000000000000001000110011 @
b10000000000 $
b10000000000 *
b111 &
b111 ,
b10011 %
b10011 +
#50
b111110100101 ;
b111110100101 E
b0 8
b0 G
b1000 7
b1000 H
b1101 :
b1101 B
b1111111000 "
b1111111000 /
b11111111111111111111111111111000 1
b110100000010000000111110100101 >
b110100000010000000111110100101 @
b11111111111111111111111111111000 &
b11111111111111111111111111111000 ,
b100011 %
b100011 +
#60
b111 ;
b111 E
b100 8
b100 G
b101 7
b101 H
b100 :
b100 B
1!
b0 "
b0 /
b100 2
b100 1
b10000100001010000000000000111 >
b10000100001010000000000000111 @
b100 '
b100 -
b100 &
b100 ,
b100 %
b100 +
#70
b11 ;
b11 E
b11110 8
b11110 G
b11010 7
b11010 H
b100011 :
b100011 B
0!
b11111111111111111111111111111111 "
b11111111111111111111111111111111 /
b101 2
b10001111110110100000000000000011 >
b10001111110110100000000000000011 @
b101 '
b101 -
#80
b101 8
b101 G
b10 7
b10 H
b101011 :
b101011 B
b10101100101000100000000000000011 >
b10101100101000100000000000000011 @
#100
1[
1Z
1Y
b100000 W
b100000 d
b100000 ~
b100000 &"
b1 Q
b1 o
b1 #"
b10 O
b10 n
b10 $"
b11 R
b11 p
b11 ""
b0 M
b0 _
b0 %"
b0 S
b0 b
b0 q
b0 v
b0 |
b0 '"
b1000100001100000100000 U
b1000100001100000100000 y
b1000100001100000100000 z
b1 ^
b1 x
b1 {
1K
#200
0K
#300
0[
1Z
1Y
b100 Q
b100 o
b100 #"
b101 O
b101 n
b101 $"
b1000 S
b1000 b
b1000 q
b1000 v
b1000 |
b1000 '"
b100000100001010000000010001000 U
b100000100001010000000010001000 y
b100000100001010000000010001000 z
b10 ^
b10 x
b10 {
1K
#400
0K
#500
1[
1Z
1Y
b1 Q
b1 o
b1 #"
b10 O
b10 n
b10 $"
b0 S
b0 b
b0 q
b0 v
b0 |
b0 '"
b1000100001100000100000 U
b1000100001100000100000 y
b1000100001100000100000 z
b11 ^
b11 x
b11 {
1K
#600
0K
#700
0[
1Z
1Y
b100 Q
b100 o
b100 #"
b101 O
b101 n
b101 $"
b1000 S
b1000 b
b1000 q
b1000 v
b1000 |
b1000 '"
b100000100001010000000010001000 U
b100000100001010000000010001000 y
b100000100001010000000010001000 z
b100 ^
b100 x
b100 {
1K
#800
0K
#900
1[
1Z
1Y
b1 Q
b1 o
b1 #"
b10 O
b10 n
b10 $"
b0 S
b0 b
b0 q
b0 v
b0 |
b0 '"
b1000100001100000100000 U
b1000100001100000100000 y
b1000100001100000100000 z
b101 ^
b101 x
b101 {
1K
#1000
0K
#1100
0[
1Z
1Y
b100 Q
b100 o
b100 #"
b101 O
b101 n
b101 $"
b1000 S
b1000 b
b1000 q
b1000 v
b1000 |
b1000 '"
b100000100001010000000010001000 U
b100000100001010000000010001000 y
b100000100001010000000010001000 z
b110 ^
b110 x
b110 {
1K
#1200
0K
#1300
1[
1Z
1Y
b1 Q
b1 o
b1 #"
b10 O
b10 n
b10 $"
b0 S
b0 b
b0 q
b0 v
b0 |
b0 '"
b1000100001100000100000 U
b1000100001100000100000 y
b1000100001100000100000 z
b111 ^
b111 x
b111 {
1K
#1400
0K
#1500
0[
1Z
1Y
b100 Q
b100 o
b100 #"
b101 O
b101 n
b101 $"
b1000 S
b1000 b
b1000 q
b1000 v
b1000 |
b1000 '"
b100000100001010000000010001000 U
b100000100001010000000010001000 y
b100000100001010000000010001000 z
b1000 ^
b1000 x
b1000 {
1K
#1600
0K
#1700
1[
1Z
1Y
b1 Q
b1 o
b1 #"
b10 O
b10 n
b10 $"
b0 S
b0 b
b0 q
b0 v
b0 |
b0 '"
b1000100001100000100000 U
b1000100001100000100000 y
b1000100001100000100000 z
b1001 ^
b1001 x
b1001 {
1K
#1800
0K
