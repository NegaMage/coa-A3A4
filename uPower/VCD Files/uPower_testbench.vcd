$date
	Sun May 17 20:28:13 2020
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module uPower_testbench $end
$var reg 1 ! clock $end
$scope module test $end
$var wire 1 " Branch $end
$var wire 1 # RegDst $end
$var wire 1 ! clock $end
$var wire 9 $ xoxo [8:0] $end
$var wire 10 % xox [9:0] $end
$var wire 2 & xods [1:0] $end
$var wire 64 ' write_data [63:0] $end
$var wire 16 ( si [15:0] $end
$var wire 64 ) rt_content [63:0] $end
$var wire 5 * rt [4:0] $end
$var wire 64 + rs_content [63:0] $end
$var wire 5 , rs [4:0] $end
$var wire 5 - rd [4:0] $end
$var wire 1 . rc $end
$var wire 6 / opcode [5:0] $end
$var wire 1 0 oe $end
$var wire 64 1 memory_read_data [63:0] $end
$var wire 1 2 lk $end
$var wire 24 3 li [23:0] $end
$var wire 32 4 instruction [31:0] $end
$var wire 14 5 ds [13:0] $end
$var wire 5 6 bo [4:0] $end
$var wire 5 7 bi [4:0] $end
$var wire 14 8 bd [13:0] $end
$var wire 1 9 aa $end
$var wire 1 : RegWrite $end
$var wire 1 ; RegRead $end
$var wire 1 < MemWrite $end
$var wire 1 = MemRead $end
$var reg 32 > PC [31:0] $end
$scope module ALU $end
$var wire 9 ? xoxo [8:0] $end
$var wire 10 @ xox [9:0] $end
$var wire 2 A xods [1:0] $end
$var wire 16 B si [15:0] $end
$var wire 5 C rt [4:0] $end
$var wire 5 D rs [4:0] $end
$var wire 6 E opcode [5:0] $end
$var wire 14 F ds [13:0] $end
$var wire 5 G bo [4:0] $end
$var wire 5 H bi [4:0] $end
$var wire 1 9 aa $end
$var reg 64 I ALU_result [63:0] $end
$var reg 1 J Branch $end
$var reg 64 K signExtendSI [63:0] $end
$var reg 64 L signed_rs [63:0] $end
$var reg 64 M signed_rt [63:0] $end
$var reg 64 N zeroExtendDS [63:0] $end
$var reg 64 O zeroExtendSI [63:0] $end
$upscope $end
$scope module InstructionMemory $end
$var wire 32 P program_counter [31:0] $end
$var reg 32 Q instruction [31:0] $end
$upscope $end
$scope module MainMemory $end
$var wire 64 R address [63:0] $end
$var wire 64 S write_data [63:0] $end
$var wire 6 T opcode [5:0] $end
$var wire 1 < MemWrite $end
$var wire 1 = MemRead $end
$var reg 64 U read_data [63:0] $end
$upscope $end
$scope module Parse $end
$var wire 32 V instruction [31:0] $end
$var wire 32 W p_count [31:0] $end
$var wire 6 X opcode [5:0] $end
$var reg 1 9 aa $end
$var reg 14 Y bd [13:0] $end
$var reg 5 Z bi [4:0] $end
$var reg 5 [ bo [4:0] $end
$var reg 14 \ ds [13:0] $end
$var reg 24 ] li [23:0] $end
$var reg 1 2 lk $end
$var reg 1 0 oe $end
$var reg 1 . rc $end
$var reg 5 ^ rd [4:0] $end
$var reg 5 _ rs [4:0] $end
$var reg 5 ` rt [4:0] $end
$var reg 16 a si [15:0] $end
$var reg 2 b xods [1:0] $end
$var reg 10 c xox [9:0] $end
$var reg 9 d xoxo [8:0] $end
$upscope $end
$scope module Registers $end
$var wire 1 # RegDst $end
$var wire 1 ! clk $end
$var wire 6 e opcode [5:0] $end
$var wire 5 f rd [4:0] $end
$var wire 5 g rs [4:0] $end
$var wire 5 h rt [4:0] $end
$var wire 64 i write_data [63:0] $end
$var wire 1 : RegWrite $end
$var wire 1 ; RegRead $end
$var reg 64 j read_data_1 [63:0] $end
$var reg 64 k read_data_2 [63:0] $end
$upscope $end
$scope module Signals $end
$var wire 6 l opcode [5:0] $end
$var wire 2 m xods [1:0] $end
$var wire 10 n xox [9:0] $end
$var wire 9 o xoxo [8:0] $end
$var reg 1 p Branch $end
$var reg 1 = MemRead $end
$var reg 1 < MemWrite $end
$var reg 1 ; RegRead $end
$var reg 1 : RegWrite $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
0p
bx o
bx n
bx m
b101010 l
bx k
bx j
b100100100111100 i
b10010 h
bx g
b1010 f
b101010 e
bx d
bx c
bx b
b100100100101010 a
b10010 `
bx _
b1010 ^
bx ]
bx \
bx [
bx Z
bx Y
b101010 X
b0 W
b10101001010100100100100100101010 V
bx U
b101010 T
bx S
b100100100111100 R
b10101001010100100100100100101010 Q
b0 P
b100100100101010 O
b0xxxxxxxxxxxxxx N
b10010 M
b0xxxxx L
b100100100101010 K
xJ
b100100100111100 I
bx H
bx G
bx F
b101010 E
bx D
b10010 C
b100100100101010 B
bx A
bx @
bx ?
b0 >
1=
0<
1;
1:
x9
bx 8
bx 7
bx 6
bx 5
b10101001010100100100100100101010 4
bx 3
x2
bx 1
x0
b101010 /
x.
b1010 -
bx ,
bx +
b10010 *
bx )
b100100100101010 (
b100100100111100 '
bx &
bx %
bx $
z#
x"
0!
$end
#100
b1001001001010 N
b1010 M
0:
0;
0=
b10 &
b10 A
b10 b
b10 m
b1001001001010 5
b1001001001010 F
b1001001001010 \
b1010 *
b1010 C
b1010 `
b1010 h
b10010 -
b10010 ^
b10010 f
b10100 /
b10100 E
b10100 T
b10100 X
b10100 e
b10100 l
b1010010010010100100100100101010 4
b1010010010010100100100100101010 Q
b1010010010010100100100100101010 V
b1 >
b1 P
b1 W
1!
#200
0!
#300
b1111111111111111111111111111111111111111111111111001001001010100 '
b1111111111111111111111111111111111111111111111111001001001010100 I
b1111111111111111111111111111111111111111111111111001001001010100 R
b1111111111111111111111111111111111111111111111111001001001010100 i
b1111111111111111111111111111111111111111111111111001001001001010 K
b1001001001001010 O
1<
1;
b1001001001001010 (
b1001001001001010 B
b1001001001001010 a
b100100 /
b100100 E
b100100 T
b100100 X
b100100 e
b100100 l
b10010010010010101001001001001010 4
b10010010010010101001001001001010 Q
b10010010010010101001001001001010 V
b10 >
b10 P
b10 W
1!
#400
0!
#500
1J
0;
0<
0p
02
19
b100101001001100111101101 3
b100101001001100111101101 ]
b10010 /
b10010 E
b10010 T
b10010 X
b10010 e
b10010 l
b1001010010100100110011110110110 4
b1001010010100100110011110110110 Q
b1001010010100100110011110110110 V
b11 >
b11 P
b11 W
1!
#600
0!
#700
b0xxxxxxxxxxxxxx N
b0xxxxx M
bx &
bx A
bx b
bx m
bx 5
bx F
bx \
bx *
bx C
bx `
bx h
bx -
bx ^
bx f
bx /
bx E
bx T
bx X
bx e
bx l
bx 4
bx Q
bx V
b100101001001100111101101 >
b100101001001100111101101 P
b100101001001100111101101 W
1!
#800
0!
#900
b100101001001100111101110 >
b100101001001100111101110 P
b100101001001100111101110 W
1!
#1000
0!
#1100
b100101001001100111101111 >
b100101001001100111101111 P
b100101001001100111101111 W
1!
#1200
0!
#1300
b100101001001100111110000 >
b100101001001100111110000 P
b100101001001100111110000 W
1!
#1400
0!
#1500
b100101001001100111110001 >
b100101001001100111110001 P
b100101001001100111110001 W
1!
#1600
0!
#1700
b100101001001100111110010 >
b100101001001100111110010 P
b100101001001100111110010 W
1!
#1800
0!
