$date
	Fri Jun 12 20:19:38 2020
$end
$version
	Icarus Verilog
$end
$timescale
	1ns
$end
$scope module alu64bittb $end
$var wire 1 ! branch $end
$var wire 64 " ALU_result [63:0] $end
$var reg 1 # aa $end
$var reg 5 $ bi [4:0] $end
$var reg 5 % bo [4:0] $end
$var reg 14 & ds [13:0] $end
$var reg 6 ' opcode [5:0] $end
$var reg 5 ( rs [4:0] $end
$var reg 5 ) rt [4:0] $end
$var reg 16 * si [15:0] $end
$var reg 2 + xods [1:0] $end
$var reg 10 , xox [9:0] $end
$var reg 9 - xoxo [8:0] $end
$scope module testerboi $end
$var wire 1 # aa $end
$var wire 5 . bi [4:0] $end
$var wire 5 / bo [4:0] $end
$var wire 14 0 ds [13:0] $end
$var wire 6 1 opcode [5:0] $end
$var wire 5 2 rs [4:0] $end
$var wire 5 3 rt [4:0] $end
$var wire 16 4 si [15:0] $end
$var wire 2 5 xods [1:0] $end
$var wire 10 6 xox [9:0] $end
$var wire 9 7 xoxo [8:0] $end
$var reg 64 8 ALU_result [63:0] $end
$var reg 1 ! Branch $end
$var reg 64 9 signExtendSI [63:0] $end
$var reg 64 : signed_rs [63:0] $end
$var reg 64 ; signed_rt [63:0] $end
$var reg 64 < zeroExtendDS [63:0] $end
$var reg 64 = zeroExtendSI [63:0] $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b0zzzzzzzzzzzzzzzz =
b0xxxxxxxxxxxxxx <
b101 ;
b11 :
bz 9
b1000 8
b100001010 7
bx 6
bx 5
bz 4
b101 3
b11 2
b11111 1
bx 0
bx /
bx .
b100001010 -
bx ,
bx +
bx *
b101 )
b11 (
b11111 '
bx &
bx %
bx $
x#
b1000 "
0!
$end
#10
b0 ;
b1110 :
b1110 (
b1110 2
b0 )
b0 3
b101000 '
b101000 1
#20
b110011 "
b110011 8
b11011 ;
b11000 :
b11000 (
b11000 2
b11011 )
b11011 3
b11100 ,
b11100 6
b11111 '
b11111 1
#30
b11 "
b11 8
b1 ;
b10 :
b10 (
b10 2
b1 )
b1 3
b100111100 ,
b100111100 6
#40
1!
b0 "
b0 8
b100 ;
b11 :
b11 (
b11 2
b100 )
b100 3
0#
b10011 '
b10011 1
#50
0!
b1000 ;
b1000 )
b1000 3
b100100 '
b100100 1
b1111101000 *
#60
b101 "
b101 8
b1 <
b100 ;
b11111010 *
b100 )
b100 3
b111010 '
b111010 1
b1 &
b1 0
#70
