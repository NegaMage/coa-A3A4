$date
	Sat Jun 13 21:39:20 2020
$end
$version
	Icarus Verilog
$end
$timescale
	1ns
$end
$scope module alu64bittb $end
$var wire 1 ! branch $end
$var wire 64 " ALU_result [63:0] $end
$var reg 1 # aa $end
$var reg 5 $ bi [4:0] $end
$var reg 5 % bo [4:0] $end
$var reg 14 & ds [13:0] $end
$var reg 6 ' opcode [5:0] $end
$var reg 5 ( rs [4:0] $end
$var reg 5 ) rt [4:0] $end
$var reg 16 * si [15:0] $end
$var reg 2 + xods [1:0] $end
$var reg 10 , xox [9:0] $end
$var reg 9 - xoxo [8:0] $end
$scope module testerboi $end
$var wire 1 # aa $end
$var wire 5 . bi [4:0] $end
$var wire 5 / bo [4:0] $end
$var wire 14 0 ds [13:0] $end
$var wire 6 1 opcode [5:0] $end
$var wire 5 2 rs [4:0] $end
$var wire 5 3 rt [4:0] $end
$var wire 16 4 si [15:0] $end
$var wire 2 5 xods [1:0] $end
$var wire 10 6 xox [9:0] $end
$var wire 9 7 xoxo [8:0] $end
$var reg 64 8 ALU_result [63:0] $end
$var reg 1 ! Branch $end
$var reg 64 9 signExtendSI [63:0] $end
$var reg 64 : signed_rs [63:0] $end
$var reg 64 ; signed_rt [63:0] $end
$var reg 64 < zeroExtendDS [63:0] $end
$var reg 64 = zeroExtendSI [63:0] $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b11111010 =
b0xxxxxxxxxxxxxx <
b101 ;
b11 :
b11111010 9
b1000 8
b100001010 7
bx 6
bx 5
b11111010 4
b101 3
b11 2
b11111 1
bx 0
bx /
bx .
b100001010 -
bx ,
bx +
b11111010 *
b101 )
b11 (
b11111 '
bx &
bx %
bx $
x#
b1000 "
0!
$end
#10
b10001 "
b10001 8
b11111 ;
b1110 :
b1110 (
b1110 2
b11111 )
b11111 3
b101000 -
b101000 7
#20
b1100 "
b1100 8
b1100 ;
b1101 :
b1101 (
b1101 2
b1100 )
b1100 3
b11100 ,
b11100 6
b0 -
b0 7
#30
b11010 "
b11010 8
b1011 ;
b10001 :
b10001 (
b10001 2
b1011 )
b1011 3
b100111100 ,
b100111100 6
#40
1!
b0 "
b0 8
b100 ;
b11 :
b11 (
b11 2
b100 )
b100 3
0#
b10011 '
b10011 1
#50
b1111101000 9
b1111101000 =
b100000010 "
b100000010 8
0!
b1000 ;
b1000 )
b1000 3
b100100 '
b100100 1
b1111101000 *
b1111101000 4
#60
b1 <
b11111010 9
b11111010 =
b100 ;
b11111010 *
b11111010 4
b100 )
b100 3
b111010 '
b111010 1
b1 &
b1 0
#70
